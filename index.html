<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Vocal ‚Üí Cinematic Choir Orchestra v11</title>
<style>
body { background:#0c0c0c; color:#fff; font-family:sans-serif; text-align:center; padding:20px;}
h1 { color:#C47E2C; margin-bottom:20px; }
.panel { background:#1a1a1a; margin:15px auto; padding:20px; border-radius:12px; max-width:900px; border:1px solid #C47E2C22; }
label { display:block; margin-top:10px; font-size:14px; }
input[type=range], select, input[type=text], input[type=file] { width:100%; margin-top:5px; }
button { background:#C47E2C; border:none; color:white; padding:10px 20px; margin:10px; border-radius:8px; cursor:pointer; font-size:16px; }
button:disabled { background:#666; cursor:not-allowed; }
.status { background:#2a2a2a; padding:10px; border-radius:8px; margin:10px; font-family:monospace; min-height:20px; }
.harmony-visual { display:flex; justify-content:center; margin:20px 0; gap:5px; }
.harmony-note { background:#C47E2C; color:#000; padding:10px; border-radius:5px; font-weight:bold; min-width:30px; }
.input-selector { display:flex; justify-content:center; gap:20px; margin:20px 0; }
.input-option { padding:10px 20px; border:2px solid #C47E2C; border-radius:8px; cursor:pointer; }
.input-option.active { background:#C47E2C; color:#000; }
.file-info { background:#2a2a2a; padding:10px; border-radius:8px; margin:10px; }
.audio-player { width:100%; margin:10px 0; }
.audio-controls { display:flex; justify-content:center; gap:10px; margin:10px 0; }
.progress-bar { width:100%; height:20px; background:#333; border-radius:10px; margin:10px 0; overflow:hidden; }
.progress-fill { height:100%; background:#C47E2C; width:0%; transition:width 0.1s; }
.export-options { display:flex; flex-wrap:wrap; justify-content:center; gap:10px; margin:10px 0; }
.export-btn { background:#2a5c8c; }
.export-btn:hover { background:#3a6c9c; }
</style>
<script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"></script>
<script src="https://unpkg.com/pitchfinder@2.3.5/dist/pitchfinder.umd.js"></script>
</head>
<body>

<h1>üéµ Cinematic Choir Orchestra v11</h1>

<div class="panel">
<h3>Audio Input Source</h3>
<div class="input-selector">
    <div class="input-option active" data-input="mic">üé§ Microphone</div>
    <div class="input-option" data-input="file">üìÅ Audio File</div>
</div>

<div id="micSection">
    <h4>Microphone Input</h4>
    <button id="micBtn">Activate Microphone</button>
    <div class="status" id="micStatus">Microphone: Not active</div>
</div>

<div id="fileSection" style="display:none;">
    <h4>Audio File Input</h4>
    <input type="file" id="audioFile" accept="audio/*" />
    <div class="file-info" id="fileInfo">No file selected</div>
    <audio id="audioPreview" controls class="audio-player" style="display:none;"></audio>
    <div class="audio-controls">
        <button id="playFileBtn" disabled>‚ñ∂ Play</button>
        <button id="pauseFileBtn" disabled>‚è∏ Pause</button>
        <button id="stopFileBtn" disabled>‚èπ Stop</button>
        <button id="loopFileBtn" disabled>‚Üª Toggle Loop</button>
    </div>
    <div class="progress-bar">
        <div class="progress-fill" id="playbackProgress"></div>
    </div>
    <div class="status" id="fileStatus">File: Not loaded</div>
</div>

<button id="startChoirBtn" disabled>Start Cinematic Choir</button>
<button id="previewProcessedBtn" disabled>üéß Preview Processed</button>
<div class="status" id="status">Status: Waiting for input...</div>
</div>

<div class="panel">
<h3>Choir Settings</h3>
<label>Octave Layers: <span id="octavesText">3</span></label>
<input type="range" id="octaves" min="1" max="6" value="3">

<label>Voices per Layer: <span id="voicesText">6</span></label>
<input type="range" id="voices" min="2" max="12" value="6">

<label>Pitch Shift Range: <span id="pitchRangeText">¬±12</span> semitones</label>
<input type="range" id="pitchRange" min="0" max="24" value="12">

<label>Stereo Width: <span id="widthText">0.7</span></label>
<input type="range" id="width" min="0" max="1" step="0.01" value="0.7">

<label>Reverb Amount: <span id="reverbText">0.6</span></label>
<input type="range" id="reverb" min="0" max="1" step="0.01" value="0.6">

<label>Detune Randomness: <span id="detuneText">18</span> cents</label>
<input type="range" id="detune" min="0" max="40" value="18">

<label>Vibrato Depth: <span id="vibratoText">0.003</span></label>
<input type="range" id="vibrato" min="0.001" max="0.01" step="0.001" value="0.003">

<label>Breath / Humanization: <span id="breathText">0.05</span></label>
<input type="range" id="breath" min="0" max="0.2" step="0.01" value="0.05">

<label>Attack/Release Time: <span id="adsrText">0.1s / 0.5s</span></label>
<input type="range" id="adsr" min="0" max="100" value="15">

<label>Playback Speed: <span id="playbackSpeedText">1.0</span>x</label>
<input type="range" id="playbackSpeed" min="0.5" max="2" step="0.1" value="1">

<label>Loop Audio: <input type="checkbox" id="loopAudio" checked></label>

<label>Harmony Preset:</label>
<select id="preset">
<option value="gospel">Gospel Choir (7th chords)</option>
<option value="cinematic">Cinematic (suspensions)</option>
<option value="angelic">Angelic Air (4ths & 5ths)</option>
<option value="octaves">Octave Stack</option>
<option value="unison">Wide Unison</option>
<option value="cluster">Cluster Harmony</option>
<option value="jazz">Jazz 9th</option>
</select>

<label>Key (Auto-Tune):</label>
<select id="key">
<option value="C">C Major</option>
<option value="Cm">C Minor</option>
<option value="D">D Major</option>
<option value="Dm">D Minor</option>
<option value="E">E Major</option>
<option value="Em">E Minor</option>
<option value="F">F Major</option>
<option value="Fm">F Minor</option>
<option value="G">G Major</option>
<option value="Gm">G Minor</option>
<option value="A">A Major</option>
<option value="Am">A Minor</option>
<option value="B">B Major</option>
<option value="Bm">B Minor</option>
</select>

<label>Custom Intervals (comma-separated semitones):</label>
<input type="text" id="customIntervals" placeholder="0,4,7,12">

<label>Automation Speed (seconds per sweep): <span id="autoSpeedText">15</span></label>
<input type="range" id="autoSpeed" min="5" max="60" value="15">

<label>Pitch Tracking Sensitivity: <span id="sensitivityText">0.1</span></label>
<input type="range" id="sensitivity" min="0.01" max="0.5" step="0.01" value="0.1">

<div id="harmonyDisplay" class="harmony-visual"></div>
</div>

<div class="panel">
<h3>Recording / Export</h3>
<div class="export-options">
    <button id="recordBtn" disabled>‚è∫ Record Live</button>
    <button id="renderBtn" disabled>‚ö° Render Entire File</button>
    <button id="exportPresetsBtn" disabled>üíæ Export Presets</button>
</div>
<div class="progress-bar" id="renderProgressBar" style="display:none;">
    <div class="progress-fill" id="renderProgress"></div>
</div>
<div class="audio-controls" id="processedControls" style="display:none;">
    <button id="playProcessedBtn">‚ñ∂ Play Processed</button>
    <button id="pauseProcessedBtn">‚è∏ Pause</button>
    <button id="downloadProcessedBtn">‚¨á Download Processed</button>
</div>
<button id="stopRecordBtn" disabled>Stop & Download WAV</button>
<button id="stopChoirBtn" disabled>Stop Choir</button>
<div class="status" id="exportStatus"></div>
</div>

<script>
// ======= UI RANGE UPDATE =======
function bindRange(id, labelId) {
    const el = document.getElementById(id);
    const label = document.getElementById(labelId);
    el.oninput = function() {
        label.textContent = this.value;
    };
}
bindRange("octaves", "octavesText");
bindRange("voices", "voicesText");
bindRange("width", "widthText");
bindRange("reverb", "reverbText");
bindRange("detune", "detuneText");
bindRange("vibrato", "vibratoText");
bindRange("breath", "breathText");
bindRange("autoSpeed", "autoSpeedText");
bindRange("pitchRange", "pitchRangeText");
bindRange("sensitivity", "sensitivityText");

// Update ADSR label
document.getElementById('adsr').oninput = function() {
    const value = parseInt(this.value);
    const attack = (value / 100).toFixed(2);
    const release = (value / 20).toFixed(2);
    document.getElementById('adsrText').textContent = `${attack}s / ${release}s`;
};

// Update playback speed label
document.getElementById('playbackSpeed').oninput = function() {
    document.getElementById('playbackSpeedText').textContent = `${parseFloat(this.value).toFixed(1)}x`;
};

// ======= Variables =======
let micStream = null;
let audioInput = null; // Can be Tone.UserMedia or Tone.Player
let audioBuffer = null;
let processedAudioBuffer = null;
let masterGain, reverbNode, compressor;
let choirLayers = [];
let mediaRecorder, recordedChunks = [];
let analyser, pitchDetector, isChoirRunning = false;
let animationFrameId = null;
let currentPitch = 440;
let pitchHistory = [];
let lastNoteTime = 0;
let currentInputType = 'mic'; // 'mic' or 'file'
let isFileLooping = true;
let isProcessingFile = false;
let processedPlayer = null;

// ======= Input Source Selection =======
document.querySelectorAll('.input-option').forEach(option => {
    option.addEventListener('click', function() {
        document.querySelectorAll('.input-option').forEach(opt => opt.classList.remove('active'));
        this.classList.add('active');
        currentInputType = this.dataset.input;
        
        // Show/hide sections
        if (currentInputType === 'mic') {
            document.getElementById('micSection').style.display = 'block';
            document.getElementById('fileSection').style.display = 'none';
            document.getElementById('startChoirBtn').disabled = !micStream;
            document.getElementById('renderBtn').disabled = true;
        } else {
            document.getElementById('micSection').style.display = 'none';
            document.getElementById('fileSection').style.display = 'block';
            document.getElementById('startChoirBtn').disabled = !audioBuffer;
            document.getElementById('renderBtn').disabled = !audioBuffer;
        }
        document.getElementById('previewProcessedBtn').disabled = true;
    });
});

// ======= Music Theory Helpers =======
function getScaleForKey(key) {
    const scales = {
        // Major scales
        'C': [0, 2, 4, 5, 7, 9, 11],
        'D': [2, 4, 6, 7, 9, 11, 13],
        'E': [4, 6, 8, 9, 11, 13, 15],
        'F': [5, 7, 9, 10, 12, 14, 16],
        'G': [7, 9, 11, 12, 14, 16, 18],
        'A': [9, 11, 13, 14, 16, 18, 20],
        'B': [11, 13, 15, 16, 18, 20, 22],
        // Minor scales
        'Cm': [0, 2, 3, 5, 7, 8, 10],
        'Dm': [2, 4, 5, 7, 9, 10, 12],
        'Em': [4, 6, 7, 9, 11, 12, 14],
        'Fm': [5, 7, 8, 10, 12, 13, 15],
        'Gm': [7, 9, 10, 12, 14, 15, 17],
        'Am': [9, 11, 12, 14, 16, 17, 19],
        'Bm': [11, 13, 14, 16, 18, 19, 21]
    };
    return scales[key] || scales['C'];
}

function frequencyToNote(freq) {
    if (!freq || freq < 20) return null;
    const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const semitone = Math.round(12 * Math.log2(freq / 440)) + 69;
    const octave = Math.floor(semitone / 12) - 1;
    const noteIndex = semitone % 12;
    return noteNames[noteIndex] + octave;
}

function snapToScale(freq, key) {
    if (!freq || freq < 20) return freq;
    const scale = getScaleForKey(key);
    const semitone = Math.round(12 * Math.log2(freq / 440)) + 69;
    const rootSemitone = key.includes('m') ? 60 : 60;
    const relativeSemitone = semitone - rootSemitone;
    const octave = Math.floor(relativeSemitone / 12) * 12;
    const scaleDegree = Math.round((relativeSemitone % 12) / 2) * 2;
    const snappedSemitone = rootSemitone + octave + (scale.includes(scaleDegree % 12) ? scaleDegree : Math.round(scaleDegree / 2) * 2);
    return 440 * Math.pow(2, (snappedSemitone - 69) / 12);
}

// ======= Harmony Presets =======
function getPresetIntervals(type) {
    switch(type) {
        case "gospel": return [0, 4, 7, 10, 12, 14, 16];
        case "cinematic": return [0, 2, 4, 7, 11, 12];
        case "angelic": return [0, 5, 7, 12, 17, 19];
        case "octaves": return [-12, 0, 12, 24];
        case "unison": return [0, 0, 0, 0, 0, 0];
        case "cluster": return [0, 1, 2, 3, 11, 12];
        case "jazz": return [0, 4, 7, 10, 14, 16];
        default: return [0, 4, 7];
    }
}

function updateHarmonyDisplay(intervals) {
    const display = document.getElementById('harmonyDisplay');
    display.innerHTML = '';
    intervals.forEach(interval => {
        const note = interval >= 0 ? `+${interval}` : interval;
        const div = document.createElement('div');
        div.className = 'harmony-note';
        div.textContent = note;
        div.title = `${interval} semitones`;
        display.appendChild(div);
    });
}

// ======= Pitch Detection =======
function createPitchDetector() {
    const detectors = [
        pitchfinder.DynamicWavelet(),
        pitchfinder.YIN(),
        pitchfinder.AMDF()
    ];
    
    return {
        detect: (audioData) => {
            let validFreqs = [];
            
            for (const detector of detectors) {
                try {
                    const freq = detector(audioData, Tone.context.sampleRate);
                    if (freq && freq > 80 && freq < 1000) {
                        validFreqs.push(freq);
                    }
                } catch (e) {}
            }
            
            if (validFreqs.length === 0) return null;
            
            validFreqs.sort((a, b) => a - b);
            return validFreqs[Math.floor(validFreqs.length / 2)];
        }
    };
}

// ======= Microphone Activation =======
document.getElementById("micBtn").onclick = async () => {
    if (micStream) {
        alert("Microphone already active!");
        return;
    }
    
    try {
        micStream = await navigator.mediaDevices.getUserMedia({ 
            audio: { 
                echoCancellation: false,
                noiseSuppression: false,
                autoGainControl: false,
                channelCount: 1,
                sampleRate: 44100
            } 
        });
        document.getElementById("startChoirBtn").disabled = false;
        document.getElementById("micStatus").textContent = "Microphone: Active ‚úì";
        alert("Microphone activated! Click 'Start Cinematic Choir'");
    } catch (error) {
        document.getElementById("micStatus").textContent = "Microphone: Error accessing";
        alert("Error accessing microphone: " + error.message);
    }
};

// ======= Audio File Handling =======
document.getElementById('audioFile').addEventListener('change', async function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    document.getElementById('fileInfo').textContent = `Loading: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
    document.getElementById('fileStatus').textContent = "File: Loading...";
    
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const arrayBuffer = await file.arrayBuffer();
        audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        document.getElementById('fileInfo').textContent = 
            `Loaded: ${file.name} | ${audioBuffer.duration.toFixed(2)}s | ${audioBuffer.sampleRate}Hz`;
        document.getElementById('fileStatus').textContent = "File: Ready ‚úì";
        document.getElementById('startChoirBtn').disabled = false;
        document.getElementById('renderBtn').disabled = false;
        
        const audioPreview = document.getElementById('audioPreview');
        audioPreview.src = URL.createObjectURL(file);
        audioPreview.style.display = 'block';
        
        document.getElementById('playFileBtn').disabled = false;
        document.getElementById('pauseFileBtn').disabled = false;
        document.getElementById('stopFileBtn').disabled = false;
        document.getElementById('loopFileBtn').disabled = false;
        
        audioContext.close();
        
    } catch (error) {
        document.getElementById('fileStatus').textContent = "File: Error loading";
        alert("Error loading audio file: " + error.message);
    }
});

// Audio file playback controls
document.getElementById('playFileBtn').onclick = function() {
    const preview = document.getElementById('audioPreview');
    preview.play();
};

document.getElementById('pauseFileBtn').onclick = function() {
    const preview = document.getElementById('audioPreview');
    preview.pause();
};

document.getElementById('stopFileBtn').onclick = function() {
    const preview = document.getElementById('audioPreview');
    preview.pause();
    preview.currentTime = 0;
    document.getElementById('playbackProgress').style.width = '0%';
};

document.getElementById('loopFileBtn').onclick = function() {
    const preview = document.getElementById('audioPreview');
    isFileLooping = !isFileLooping;
    preview.loop = isFileLooping;
    this.textContent = isFileLooping ? '‚Üª Looping On' : '‚Ü∫ Looping Off';
};

// Update playback progress
const audioPreview = document.getElementById('audioPreview');
audioPreview.addEventListener('timeupdate', function() {
    const progress = (this.currentTime / this.duration) * 100 || 0;
    document.getElementById('playbackProgress').style.width = `${progress}%`;
});

// ======= Preview Processed Audio =======
document.getElementById('previewProcessedBtn').onclick = function() {
    if (!processedAudioBuffer) {
        alert("No processed audio available. Please render or record first.");
        return;
    }
    
    if (processedPlayer && processedPlayer.state === 'started') {
        processedPlayer.stop();
        this.textContent = 'üéß Preview Processed';
    } else {
        processedPlayer = new Tone.Player(processedAudioBuffer).toDestination();
        processedPlayer.start();
        this.textContent = '‚èπ Stop Preview';
        processedPlayer.onstop = () => {
            this.textContent = 'üéß Preview Processed';
        };
    }
};

// ======= Start Cinematic Choir =======
document.getElementById("startChoirBtn").onclick = async () => {
    if (currentInputType === 'mic' && !micStream) {
        alert("Activate microphone first!");
        return;
    }
    
    if (currentInputType === 'file' && !audioBuffer) {
        alert("Load an audio file first!");
        return;
    }
    
    await Tone.start();
    Tone.context.resume();
    
    // Get parameters
    const octaves = parseInt(document.getElementById("octaves").value);
    const voicesPerLayer = parseInt(document.getElementById("voices").value);
    const width = parseFloat(document.getElementById("width").value);
    const detuneAmount = parseFloat(document.getElementById("detune").value);
    const vibratoDepth = parseFloat(document.getElementById("vibrato").value);
    const breathDepth = parseFloat(document.getElementById("breath").value);
    const reverbAmount = parseFloat(document.getElementById("reverb").value);
    const pitchRange = parseInt(document.getElementById("pitchRange").value);
    const presetType = document.getElementById("preset").value;
    const key = document.getElementById("key").value;
    const autoSpeed = parseFloat(document.getElementById("autoSpeed").value);
    const sensitivity = parseFloat(document.getElementById("sensitivity").value);
    const adsrValue = parseInt(document.getElementById("adsr").value);
    const playbackSpeed = parseFloat(document.getElementById("playbackSpeed").value);
    const loopAudio = document.getElementById("loopAudio").checked;
    
    let customIntervals = document.getElementById("customIntervals").value
        .split(",")
        .map(n => parseInt(n.trim()))
        .filter(n => !isNaN(n));
    
    const baseIntervals = customIntervals.length > 0 ? customIntervals : getPresetIntervals(presetType);
    updateHarmonyDisplay(baseIntervals);
    
    // Clear previous layers
    choirLayers.forEach(layer => {
        layer.forEach(voice => {
            voice.cleanup();
        });
    });
    choirLayers = [];
    
    // Setup audio graph
    masterGain = new Tone.Gain(0.7).toDestination();
    compressor = new Tone.Compressor({
        threshold: -20,
        ratio: 4,
        attack: 0.003,
        release: 0.25
    }).connect(masterGain);
    
    reverbNode = new Tone.Reverb({
        decay: 3,
        wet: reverbAmount
    }).connect(compressor);
    
    // Create audio input based on selected source
    if (audioInput) {
        audioInput.disconnect();
        if (audioInput.dispose) audioInput.dispose();
    }
    
    if (currentInputType === 'mic') {
        audioInput = new Tone.UserMedia();
        await audioInput.open(micStream);
        document.getElementById("status").textContent = "Status: Using microphone input";
    } else {
        audioInput = new Tone.Player({
            url: audioBuffer,
            loop: loopAudio,
            playbackRate: playbackSpeed
        }).connect(masterGain);
        document.getElementById("status").textContent = "Status: Using file input";
    }
    
    // Create analyser for pitch detection
    analyser = Tone.context.createAnalyser();
    analyser.fftSize = 4096;
    analyser.smoothingTimeConstant = 0.8;
    audioInput.connect(analyser);
    
    // Start audio playback if it's a file
    if (currentInputType === 'file') {
        audioInput.start();
    }
    
    // Initialize pitch detector
    pitchDetector = createPitchDetector();
    
    // Create layers with voices
    for (let o = 0; o < octaves; o++) {
        let layer = [];
        for (let v = 0; v < voicesPerLayer; v++) {
            const interval = baseIntervals[v % baseIntervals.length];
            
            const pitchShift = new Tone.PitchShift({
                pitch: interval + (o * 12),
                windowSize: 0.1,
                delayTime: 0.1
            });
            
            const filter = new Tone.Filter({
                frequency: 2000,
                type: "lowpass",
                rolloff: -12,
                Q: 1
            });
            
            const gain = new Tone.Gain({
                gain: 0.5 / (octaves * voicesPerLayer)
            });
            
            const pan = new Tone.Panner(((v / voicesPerLayer) * 2 - 1) * width);
            
            const attack = adsrValue / 100;
            const release = adsrValue / 20;
            
            audioInput.connect(pitchShift);
            pitchShift.connect(filter);
            filter.connect(pan);
            pan.connect(gain);
            gain.connect(reverbNode);
            
            layer.push({
                pitchShift: pitchShift,
                filter: filter,
                gain: gain,
                pan: pan,
                vibrato: vibratoDepth * (0.5 + Math.random() * 0.5),
                breath: breathDepth * (0.5 + Math.random() * 0.5),
                interval: interval,
                octaveShift: o * 12,
                panDirection: Math.random() > 0.5 ? 1 : -1,
                panSpeed: 0.5 + Math.random() * 1.5,
                phase: Math.random() * Math.PI * 2,
                cleanup: function() {
                    pitchShift.dispose();
                    filter.dispose();
                    gain.dispose();
                    pan.dispose();
                }
            });
        }
        choirLayers.push(layer);
    }
    
    isChoirRunning = true;
    document.getElementById("startChoirBtn").disabled = true;
    document.getElementById("stopChoirBtn").disabled = false;
    document.getElementById("recordBtn").disabled = false;
    document.getElementById("previewProcessedBtn").disabled = false;
    document.getElementById("exportPresetsBtn").disabled = false;
    document.getElementById("status").textContent = 
        `Status: Choir active (${octaves * voicesPerLayer} voices)`;
    
    // Pitch tracking and automation loop
    let lastPitchUpdate = 0;
    let stablePitch = 440;
    pitchHistory = [];
    
    function processCinematic() {
        if (!isChoirRunning) return;
        
        const now = Date.now();
        const t = now / 1000;
        
        if (now - lastPitchUpdate > 100) {
            const bufferLength = analyser.fftSize;
            const dataArray = new Float32Array(bufferLength);
            analyser.getFloatTimeDomainData(dataArray);
            
            const detectedFreq = pitchDetector.detect(dataArray);
            
            if (detectedFreq && detectedFreq > 80 && detectedFreq < 1000) {
                const autoTunedFreq = snapToScale(detectedFreq, key);
                
                pitchHistory.push(autoTunedFreq);
                if (pitchHistory.length > 10) pitchHistory.shift();
                
                const avgFreq = pitchHistory.reduce((a, b) => a + b, 0) / pitchHistory.length;
                stablePitch = stablePitch * 0.9 + avgFreq * 0.1;
                currentPitch = stablePitch;
                
                const note = frequencyToNote(stablePitch);
                if (note && now - lastNoteTime > 500) {
                    document.getElementById("status").textContent = 
                        `Status: Choir active | Detected: ${note} (${Math.round(stablePitch)}Hz) | ${octaves * voicesPerLayer} voices`;
                    lastNoteTime = now;
                }
            }
            lastPitchUpdate = now;
        }
        
        choirLayers.forEach((layer, layerIndex) => {
            layer.forEach((voice, voiceIndex) => {
                const panValue = Math.sin(t / voice.panSpeed + voice.phase) * width;
                voice.pan.pan.value = panValue;
                
                const vib = 1 + voice.vibrato * Math.sin(t * 6 + voiceIndex * 0.5);
                const br = 1 - voice.breath * Math.sin(t * 0.2 + layerIndex * 0.3);
                const volume = (vib * br * 0.5) / (octaves * voicesPerLayer);
                voice.gain.gain.rampTo(volume, 0.1);
                
                const filterFreq = 500 + currentPitch * 0.5 + Math.sin(t * 2) * 200;
                voice.filter.frequency.rampTo(filterFreq, 0.2);
                
                const randomDetune = (Math.random() - 0.5) * detuneAmount * 2;
                voice.pitchShift.pitch = voice.interval + voice.octaveShift + randomDetune / 100;
                
                const pitchMod = Math.sin(t / autoSpeed + layerIndex) * pitchRange;
                voice.pitchShift.pitch += pitchMod;
            });
        });
        
        animationFrameId = requestAnimationFrame(processCinematic);
    }
    
    processCinematic();
};

// ======= Render Entire Audio File (Offline) =======
document.getElementById("renderBtn").onclick = async () => {
    if (!audioBuffer || isProcessingFile) return;
    
    isProcessingFile = true;
    document.getElementById("renderProgressBar").style.display = 'block';
    document.getElementById("renderProgress").style.width = '0%';
    document.getElementById("exportStatus").textContent = "Status: Rendering audio file...";
    
    try {
        // Get current settings
        const octaves = parseInt(document.getElementById("octaves").value);
        const voicesPerLayer = parseInt(document.getElementById("voices").value);
        const width = parseFloat(document.getElementById("width").value);
        const detuneAmount = parseFloat(document.getElementById("detune").value);
        const vibratoDepth = parseFloat(document.getElementById("vibrato").value);
        const breathDepth = parseFloat(document.getElementById("breath").value);
        const reverbAmount = parseFloat(document.getElementById("reverb").value);
        const pitchRange = parseInt(document.getElementById("pitchRange").value);
        const presetType = document.getElementById("preset").value;
        const key = document.getElementById("key").value;
        const autoSpeed = parseFloat(document.getElementById("autoSpeed").value);
        const adsrValue = parseInt(document.getElementById("adsr").value);
        
        let customIntervals = document.getElementById("customIntervals").value
            .split(",")
            .map(n => parseInt(n.trim()))
            .filter(n => !isNaN(n));
        
        const baseIntervals = customIntervals.length > 0 ? customIntervals : getPresetIntervals(presetType);
        
        // Create offline context
        const offlineContext = new OfflineAudioContext(
            2, // stereo
            audioBuffer.length,
            audioBuffer.sampleRate
        );
        
        // Create source
        const source = offlineContext.createBufferSource();
        source.buffer = audioBuffer;
        
        // Create audio nodes
        const compressor = offlineContext.createDynamicsCompressor();
        compressor.threshold.value = -20;
        compressor.ratio.value = 4;
        
        const reverb = offlineContext.createConvolver();
        
        // Create all voice nodes
        const voices = [];
        for (let o = 0; o < octaves; o++) {
            for (let v = 0; v < voicesPerLayer; v++) {
                const interval = baseIntervals[v % baseIntervals.length];
                
                // Create pitch shifter (simulated by changing playback rate)
                const pitchShift = offlineContext.createGain();
                
                // Create panner
                const panner = offlineContext.createStereoPanner();
                panner.pan.value = ((v / voicesPerLayer) * 2 - 1) * width;
                
                // Create gain node
                const gain = offlineContext.createGain();
                gain.gain.value = 0.5 / (octaves * voicesPerLayer);
                
                // Connect: source ‚Üí pitchShift ‚Üí panner ‚Üí gain ‚Üí compressor ‚Üí destination
                source.connect(pitchShift);
                pitchShift.connect(panner);
                panner.connect(gain);
                gain.connect(compressor);
                
                voices.push({
                    panner: panner,
                    gain: gain,
                    interval: interval,
                    octaveShift: o * 12,
                    panSpeed: 0.5 + Math.random() * 1.5,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }
        
        compressor.connect(offlineContext.destination);
        source.start(0);
        
        // Schedule automation during rendering
        const duration = audioBuffer.duration;
        const updateInterval = 0.1; // Update every 100ms
        
        for (let time = 0; time < duration; time += updateInterval) {
            voices.forEach((voice, index) => {
                const t = time;
                const panValue = Math.sin(t / voice.panSpeed + voice.phase) * width;
                voice.panner.pan.setValueAtTime(panValue, time);
                
                const vib = 1 + vibratoDepth * Math.sin(t * 6 + index * 0.5);
                const br = 1 - breathDepth * Math.sin(t * 0.2 + index * 0.3);
                const volume = (vib * br * 0.5) / (octaves * voicesPerLayer);
                voice.gain.gain.setValueAtTime(volume, time);
                
                const pitchMod = Math.sin(t / autoSpeed + index) * pitchRange;
                // Note: Real pitch shifting would require more complex processing
            });
            
            // Update progress
            const progress = (time / duration) * 100;
            document.getElementById("renderProgress").style.width = `${progress}%`;
        }
        
        // Render the audio
        const renderedBuffer = await offlineContext.startRendering();
        
        // Store processed audio
        processedAudioBuffer = renderedBuffer;
        
        // Enable processed audio controls
        document.getElementById("processedControls").style.display = 'flex';
        document.getElementById("playProcessedBtn").disabled = false;
        document.getElementById("downloadProcessedBtn").disabled = false;
        
        // Create download link
        const wavBlob = audioBufferToWav(processedAudioBuffer);
        const url = URL.createObjectURL(wavBlob);
        
        document.getElementById("downloadProcessedBtn").onclick = () => {
            const a = document.createElement('a');
            a.href = url;
            a.download = `cinematic_choir_processed_${Date.now()}.wav`;
            a.click();
        };
        
        document.getElementById("exportStatus").textContent = 
            `Status: Rendering complete! ${(processedAudioBuffer.duration).toFixed(2)}s processed audio ready.`;
        
    } catch (error) {
        document.getElementById("exportStatus").textContent = "Status: Error rendering audio";
        console.error("Rendering error:", error);
        alert("Error rendering audio: " + error.message);
    } finally {
        isProcessingFile = false;
        document.getElementById("renderProgressBar").style.display = 'none';
    }
};

// ======= Export Presets =======
document.getElementById("exportPresetsBtn").onclick = () => {
    const preset = {
        octaves: parseInt(document.getElementById("octaves").value),
        voices: parseInt(document.getElementById("voices").value),
        width: parseFloat(document.getElementById("width").value),
        reverb: parseFloat(document.getElementById("reverb").value),
        detune: parseFloat(document.getElementById("detune").value),
        vibrato: parseFloat(document.getElementById("vibrato").value),
        breath: parseFloat(document.getElementById("breath").value),
        pitchRange: parseInt(document.getElementById("pitchRange").value),
        preset: document.getElementById("preset").value,
        key: document.getElementById("key").value,
        autoSpeed: parseFloat(document.getElementById("autoSpeed").value),
        customIntervals: document.getElementById("customIntervals").value,
        date: new Date().toISOString()
    };
    
    const presetStr = JSON.stringify(preset, null, 2);
    const blob = new Blob([presetStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `choir_preset_${Date.now()}.json`;
    a.click();
    
    document.getElementById("exportStatus").textContent = "Status: Preset exported!";
};

// ======= Stop Choir =======
document.getElementById("stopChoirBtn").onclick = () => {
    if (!isChoirRunning) return;
    
    isChoirRunning = false;
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
    }
    
    choirLayers.forEach(layer => {
        layer.forEach(voice => {
            voice.cleanup();
        });
    });
    choirLayers = [];
    
    if (audioInput) {
        if (audioInput.close) audioInput.close();
        audioInput.disconnect();
        audioInput = null;
    }
    
    document.getElementById("startChoirBtn").disabled = false;
    document.getElementById("stopChoirBtn").disabled = true;
    document.getElementById("recordBtn").disabled = true;
    document.getElementById("status").textContent = "Status: Choir stopped";
};

// ======= Recording =======
document.getElementById("recordBtn").onclick = async () => {
    if (!masterGain || !isChoirRunning) {
        alert("Start choir first!");
        return;
    }
    
    await Tone.context.resume();
    
    recordedChunks = [];
    
    const dest = Tone.Destination.context.createMediaStreamDestination();
    masterGain.connect(dest);
    
    mediaRecorder = new MediaRecorder(dest.stream, {
        mimeType: 'audio/webm;codecs=opus'
    });
    
    mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
            recordedChunks.push(e.data);
        }
    };
    
    mediaRecorder.onstop = async () => {
        try {
            const blob = new Blob(recordedChunks, { type: 'audio/webm' });
            
            const audioContext = new AudioContext();
            const arrayBuffer = await blob.arrayBuffer();
            processedAudioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            const wavBlob = audioBufferToWav(processedAudioBuffer);
            const url = URL.createObjectURL(wavBlob);
            
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `cinematic_choir_live_${Date.now()}.wav`;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 100);
            
            // Enable processed audio controls
            document.getElementById("processedControls").style.display = 'flex';
            document.getElementById("playProcessedBtn").disabled = false;
            document.getElementById("downloadProcessedBtn").disabled = false;
            
            document.getElementById("exportStatus").textContent = 
                `Status: Live recording complete! ${(processedAudioBuffer.duration).toFixed(2)}s recorded.`;
            
            audioContext.close();
        } catch (error) {
            console.error("Recording error:", error);
            alert("Error processing recording: " + error.message);
        }
    };
    
    mediaRecorder.start();
    document.getElementById("recordBtn").disabled = true;
    document.getElementById("stopRecordBtn").disabled = false;
    document.getElementById("status").textContent = "Status: Recording live audio...";
};

document.getElementById("stopRecordBtn").onclick = () => {
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
        document.getElementById("recordBtn").disabled = false;
        document.getElementById("stopRecordBtn").disabled = true;
    }
};

// ======= Processed Audio Controls =======
document.getElementById("playProcessedBtn").onclick = function() {
    if (!processedAudioBuffer) {
        alert("No processed audio available!");
        return;
    }
    
    if (processedPlayer && processedPlayer.state === 'started') {
        processedPlayer.stop();
        this.textContent = '‚ñ∂ Play Processed';
    } else {
        if (processedPlayer) processedPlayer.dispose();
        processedPlayer = new Tone.Player(processedAudioBuffer).toDestination();
        processedPlayer.start();
        this.textContent = '‚èπ Stop';
        processedPlayer.onstop = () => {
            this.textContent = '‚ñ∂ Play Processed';
        };
    }
};

document.getElementById("pauseProcessedBtn").onclick = () => {
    if (processedPlayer && processedPlayer.state === 'started') {
        processedPlayer.stop();
        document.getElementById("playProcessedBtn").textContent = '‚ñ∂ Play Processed';
    }
};

// ======= Audio Buffer to WAV Converter =======
function audioBufferToWav(buffer) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const format = 1;
    const bitDepth = 16;
    
    const bytesPerSample = bitDepth / 8;
    const blockAlign = numChannels * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const dataSize = buffer.length * blockAlign;
    
    const bufferLength = 44 + dataSize;
    const arrayBuffer = new ArrayBuffer(bufferLength);
    const view = new DataView(arrayBuffer);
    
    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + dataSize, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, format, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitDepth, true);
    writeString(view, 36, 'data');
    view.setUint32(40, dataSize, true);
    
    let offset = 44;
    for (let i = 0; i < buffer.length; i++) {
        for (let channel = 0; channel < numChannels; channel++) {
            const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
            const intSample = sample < 0 ? sample * 32768 : sample * 32767;
            view.setInt16(offset, intSample, true);
            offset += 2;
        }
    }
    
    return new Blob([view], { type: 'audio/wav' });
}

function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}

// ======= Initialize Harmony Display =======
updateHarmonyDisplay(getPresetIntervals('gospel'));

// ======= Preset and Interval Updates =======
document.getElementById('preset').onchange = function() {
    const intervals = getPresetIntervals(this.value);
    updateHarmonyDisplay(intervals);
};

document.getElementById('customIntervals').oninput = function() {
    const intervals = this.value
        .split(",")
        .map(n => parseInt(n.trim()))
        .filter(n => !isNaN(n));
    if (intervals.length > 0) {
        updateHarmonyDisplay(intervals);
    }
};

document.getElementById('playbackSpeed').oninput = function() {
    if (audioInput && audioInput.playbackRate) {
        audioInput.playbackRate = parseFloat(this.value);
    }
};
</script>
</body>
</html>
